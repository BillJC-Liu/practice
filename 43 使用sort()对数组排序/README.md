## 使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果 
```javascript
  [3, 15, 8, 29, 102, 22].sort(); // [102, 15, 22, 29, 3, 8]
```
  默认排序的方法会将数组元素转换为字符串，然后比较字符串中字符的UTF-16编码顺序来进行排序。所以`102`会排在`15`前面。

```javascript 
  [3, 15, 8, 29, 102, 22].sort((a ,b)=>{
    return a-b
  });
  //  [3, 8, 15, 22, 29, 102]  升序

    [3, 15, 8, 29, 102, 22].sort((a ,b)=>{
    return b-a
  });
  //  [102, 29, 22, 15, 8, 3] 降序
```
### 下面说说sort原理
不同引擎对js的sort方法解析可能存在差异，这里主要基于V8引擎进行分析。<br />
当没有参数传入的时候，其排序顺序默认为，将待排序数据转换为字符串，并按照Unicode序列排序；当然。比较函数可以自定义，自定义排序函数需要返回值，其返回值为-1,0,1分别表示 a<b, a=b, a>b。<br/>
当数组长度小于等于10的时候，采用插入排序，大于10的时候，采用快排。

### 插入排序
v8源码
```javascript 
  function InsertionSort(a, from, to) {
    for (var i = from + 1; i < to; i++) {
      var element = a[i];
      for (var j = i - 1; j >= from; j--) {
        var tmp = a[j];
        var order = comparefn(tmp, element);
        if (order > 0) {
          a[j + 1] = tmp;
        } else {
          break;
        }
      }
      a[j + 1] = element;
    }
  };
```
a表示数组，from开始数组开始排序的位置下表，to表示数组结束位置下标。根据上述代码，var arr= [ 7,3,5,2,4 ]，那么arr.sort()排序过程如下：、

7 3 5 2 4
3 7 5 2 4
3 5 7 2 4 
2 3 5 7 4 
2 3 4 5 7

虽然插入排序的复杂度是n^2，但是由于数据量很小，因此是常量的复杂度，效率很高，而且插入排序是一个稳定的排序算法。

### 快速排序
v8 源码太长，理解不透，所以没有贴出来...

v8的sort对于长度大于1000的数组采用的是`快排与插入排序混合`的方式进行排序，因为当数据量很小的时候，插入排序效率由于快排。
快排需要选择一个关键值，并且以关键值为基准开始排序，比关键值小的放左边，比关键值大的放右边，由此完成第一轮排序；然后再对关键值左侧的数据以及右侧的数据分别执行快排。如果每次关键字选择都是一组数据的最小值或者最大值，那么快排的复杂度将会达到n^2，就跟冒泡排序没什么区别了。在快排算法中，最优的关键字，是这组数据最中间位置的值，这样才能使得排序算法复杂度达到nlogn。因此，关键值的选择尤为重要。

##### v8快排关键值的获取：
* 获取临时关键值tmp：
  1.对于大于10小于等于1000的数据量，tmp为这组数据中间位置的值
  2.对于大于1000的数据，根据一定部长从待排序的数组里面获取一组临时数据，对临时数据排序，在获得临时数据最中间位置的值，作为待排序数组的tmp。步长的计算跟数组的长度有关系，其计算方法如下：
   *步长 = 200 + 数组长度&15*
  3.讲述组的长度转换为二进制后，与1111按位与，其结果与200相加，作为步长

* 计算关键字key：
  获取数组第一个数a0，最后一个数an；
  比较a0，tmp，an，赋值给v0，v1，v2，保证v0 <= v1 <= v2
  `关键值 = v1`
  通过对关键字的选取，能最大程度保证快排的复杂度趋近平均复杂度，即nlogn。
  
  例：var arr = [3,6,2,7,9,23,5,13,12,6,73,34,55,22,34]; arr.sort()排序顺序如下：
  第一趟排序：获取关键值，a0=3; an=34; tmp=arr[7]=13; 因此v0=3；v1=13；v2=34，因此key=13。小于关键值的在左边，大于的在右边。
  第二趟排序：分别对13左侧的数据，及13右侧的数据调用快排方法。
  
  由于13左侧及右侧数据量都小于10，因此会调用插入排序。因此接下来排序结果如下：
  13左侧：
  2,3,7,9,6,12,5,6
  2,3,7,9,6,12,5,6
  2,3,6,7,9,12,5,6
  2,3,5,6,7,9,12,6
  2,3,5,6,6,7,9,12
  
  13右侧:
  23,73,34,55,22,34
  23,34,73,55,22,34
  23,34,55,73,22,34
  22,23,34,55,73,34
  22,23,34,34,55,73

  最终结果：2,3,5,6,6,7,9,12,13,22,23,34,34,55,73。

  快排的平均时间复杂度是nlogn，在排序算法中属于效率最高的。快排是一种不稳定的排序算法，但是一般情况下稳定或者不稳定对我们没有特别大的影响，但是对稳定性要求高的排序，就不能使用快排了。